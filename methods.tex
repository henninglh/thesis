\part{Methods}
\label{pa:methods}
\chapter{Algorithms}
\section{Clustering}
To cluster or not to cluster is the question here. PPI networks already have
a great deal of edges and can be seen as clusters that we should not alter. On
the other hand, using clustering algorithms to make clusters out of
PPI-networks gives us the more control over the clusters. How big they should
be, how many of them we want, should we cluster on a certain attribute, or even
several? If we cluster the network, we have chosen to go with the \textit{MCL}
clustering algorithm in \textit{clusterMaker2}. I prototyped Ranklust with
\textit{Affinity Propagation}(AP), but a paper that performed a comparison
between MCL and AP concluded with MCL having the best performance in many
aspects when it came to PPI networks \cite{ap-vs-mcl}.

A drawback with clustering in CytoScape is that it directly alters the network.
However, MCL in clusterMaker2 does not create new edges between nodes. It is
keeping the ones that it qualifies as worthy to be in the cluster it is
currently creating. So it may disconnect, or delete, edges between nodes to
separate them in the clustering. This may not be feasible when ranking the
clusters afterwards, so the user should be able to choose between using
clusterMaker2's clustering algorithms, or just have clusters that already exists
through simple PPI connections between nodes.

We have used four algorithms to rank the clusters, SAA, MAA, MAM and SW-RWR.
The three first are our own simple methods, but SW-RWR is a proven ranking
algorithm for PPI-networks in cancer. It will be the SW-RWR results that have
the highest likeliness of giving successfull results, should ranking of clusters
unveil new information on network biomarkers for prostate cancer.

\section{Single Attribute Additive Method (SAA)}
Single attribute additive method is the simplest of the four algorithms. It
gives the user the option to choose a single node attribute to score the
clusters on. The attribute is required to be a number of some sort, but that is
the only constraint.

It goes through all of the nodes in each cluster and sums up the number-
attribute the user chose. Each cluster is then ranked based on the accumulated
sum and ranked descending, with the highest ranking cluster as the most likely
prostate cancer biomarker.

\section{Multiple Attribute Additive Method (MAA)}
Multiple attribute additive method is the next step. This opens up the
opportunity for the user to use an unlimited number of number-attributes on both
nodes and edges. The part after that is exactly the same as in the SAA
algorithm. It goes through all of the nodes in each cluster and sums up the
attributes for each cluster.

There is a question as to how to rank the edges in the cluster. We chose to rank
each edge as it is listed to the user in CytoScape. So if it is listed only once
time in the edge table, it will only be scored additively once. This decision
was based on simplicity. To not represent the edge as something the user did not
define it as.

\section{Multiple Attribute Multiplication Method (MAM)}
Multiple attribute multiplication method is the final step, and it is to some
degree redundant, considering what exists from before in Ranklust. The only
difference is the scale the scores will be in. MAM adds the scores from each
node and edge in the cluster through multiplication, MAA does it with addition. 

Another detail to the MAM is that it will ensure that the scores either increase
or stay the same, it will never decrease. So when values that are below one is
combined in MAM, it will gain a plus one score. In other words, 0.23 times % format!
0.5 will result in 1.23 times 1.5. The same is true for situations where only
one of the numbers is below one. 0.23 times 1.5 becomes 1.23 times 1.5. Zero
scores will get ignored.

\section{Seed-weighted Random Walks Ranking Method (SW-RWR)}
Seed-weighted random walks ranking is an addition to the Random Walks Ranking
(RWR) algorithm. Random walks algorithm in graphs is a very basic way of
traversing a graph. It requires some sort of score in either a node, or an edge.
This score represents the probability that we might visit the node. Each node in
the graph will receive a probability score equal to the sum of the probability
that we might visit that node from all of the other nodes. Since this is random
based, several runs through the graph can be done until the results stabilize.

\chapter{Creation of Neo4J database} % Insert appendix links to the scripts!
\section{Data preparation}
I created a Neo4J database and used a slightly modified CytoScape app to
communicate with it. Input to the database is a modified version of data. The
data started as a PPI file from the StringDB. The file had a size of 3,9GB and
consisted of interactions between two proteins. Each line had two Ensembl
Protein IDs (ENSP), the type of interaction, what direction the interaction went
in and a score for the interaction. 

\begin{verbatim}
item_id_a	item_id_b	mode	action	a_is_acting	score
9606.ENSP00000000233	9606.ENSP00000000233	binding		0	800
\end{verbatim}

I strip this file in order to get a file with just the ENSP IDs. One line per
ID.

\begin{verbatim}
ENSP00000000233
ENSP00000005340
\end{verbatim}

Next up is the conversion from protein IDs to gene IDs coupled with Entrez ID.
This information I got from UniProt through the stripped ENSP IDs. The file with
the data is formatted like this:

\begin{verbatim}
Entry	EnsembleID	    Gene names
P84085	ENSP00000000233	ARF5
\end{verbatim}

I match the \textit{EnsembleID} from UniProt, which is a ENSP ID, to the
\textit{item\_id\_a} and \textit{item\_id\_b} data from StringDB (without the
9606.  prefix). Then combine the Entrez id, which is the \textit{Entry} from
UniProt with \textit{Gene names} with a square (\textit{\#}) between them as
a separator to make it easier to split them when creating Cypher and GraphML
import queries for Neo4J. This combination makes up a single gene, and each line
in the file I write this information to consist of two genes and a type of
binding between them. The type of binding is provided by the StringDB file
mentioned first in this section. % label and refer instead of mentioning it!


\section{Neo4J setup and data import}

\subsection{Setup}
Not much of a setup is needed to get the database up and running. Every setting
that was changed in testing and using the database was set in the
\textit{conf/neo4j-server.properties} file, located in the directory relative to
the Neo4J database installation.

The database
location does not need to be set up, but knowing the location of the data that
is saved in the Neo4J database is somewhat crucial when working with several
database instances.

\begin{verbatim}
org.neo4j.server.database.location=data/string_mini.db
org.neo4j.server.webserver.port=7474
\end{verbatim}

NB! That path is relative to the location the neo4j database is run from.

Turning authentication on/off is also smart for testing purposes. Communicating
with a Neo4J database instance that demands authentication also requires the
usage of the modified CytoScape app \textit{CyNeo4J}. This is because the app
does support everything we need except from authenticating with a database. For
the database, this is just having a boolean value \textit{true}/\textit{false}.

\begin{verbatim}
dbms.security.auth_enabled=true
\end{verbatim}

\subsection{Import}
Importing data into Neo4J is not very mature at this point. You have the
possibility to just use Neo4J's query language, \textit{Cypher}. However,
importing the whole gene data from StringDB and UniProt combined takes a long
time in Cypher, even if the language is the native language to Neo4J. The
alternative we used was \textit{neo4j-shell-tools} \cite{neo4j-tools}. It is
easy to install and supports import with \textit{CSV}, \textit{Geoff} and
\textit{GraphML} filetypes. A GraphML import took under 1 minute on my old and
underperforming laptop with 4GB memory, 2GHz CPU and a 128GB SSD \cite{laptop}.
In comparison, the Cypher import took several hours, with the same amount of
data. I did not test importing with CSV, because CytoScape does not support
exporting data to a CSV file. On the other hand, CytoScape has great support
exporting data to a GraphML file.

The Python scripts used to initialize the Neo4J database with data create either
GraphML or Cypher. Importing any of them result in the same type of data in the
database, but because of the heavily increased speed using GraphML over Cypher,
we used GraphML exclusively to initialize the database. The nodes are created
with the forementioned \textit{Entrez ID} as primary key and \textit{Gene name}
as the displayed name in the Neo4J GUI.

\chapter{CytoScape implementation}
The secretome values of genes can be expressed by a single integer value,
though, for compatibility reasons Ranklust will require double values. The
clustered network can be constructed with an AP, short for Affinity Propagation,
clustering algorithm \cite{affinity-propagation}. Affinity propagation
clustering concentrates on the nodes in the network that are binding the rest of
them together. Using affinity propagation for clustering will produce results
that represent a grouping of nodes that are coupled by seemingly unimportant
nodes to most clustering algorithms. But the AP algorithm is good at expressing
nodes that are not highly connected to many nodes, but rather the nodes that are
binding other highly connected nodes together. This results in bigger clusters
that can be a target for methods that cure cancer by severing the interaction
between biomarker genes.

It is also discussed how AP performs versus Markov clustering \cite{ap-vs-mcl}.
And since Markov algorithm performs better on protein interaction, it will also
be used to cluster the networks. An analysis between the rankings that come from
the Markov and AP clusterings will be performed, which hopefully will give
concrete results as to the pro's and con's of each algorithm. Some questions
should be raised as the analysis is done. For example, is both of the algorithms
good, but have different uses, even if they are not directly involved with the
ranking done after the clustering?  Are either AP or Markov useless for
a particular type of ranking afterwards?

The information provided through the whole process from what type of nodes
(protein or gene), interaction between the nodes and what kind of biomarker we
want to identify are all factors that will have a great impact on how all of
this should be combined. The order of operations on the network will also effect
the result. For example, AP clustering may create a few big clusters and many
small ones. At this stage, the results will consist of the biggest clusters
constructed from AP clustering that has focus on pure connection between nodes
and not their attributes. At this point, the cluster ranking algorithm of
Ranklust will be run in order to produce a picture of potential biomarkers. This
picture is the first and simplest step that will be used as a result for an
analysis. The analysis in this thesis will focus on validating the cluster
ranking scores as ways of indicating potential biomarkers. 

In order to validate the scores, I will need to know the state of the patient
that the data to create the network came from. As there is no use to just
generate results without knowing what they show. They might show connections
between them, but without some sort of context the results are useless. The
context needed is not very high, but the results from the ranking should be
tested for several purposes. For example, is biomarkers from ranking of clusters
best for disease disposition, screening, diagnostic, prognostic, prediction or
monitoring cancer. I will aim for screening, diagnostic and most of all
prognostic usages. As mentioned earlier, the prognostics of prostate cancer
often results in 50\% of patients receiving treatment that was not needed.

