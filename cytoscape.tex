\part{Cytoscape} % Make this a subsection in "The project" part
\label{pa:cytoscape}
The structure of the code in Cytoscape follows the already established structure
in the ClusterMaker2 plugin. This is to make it easy to maintain for the other
contributors of ClusterMaker2. At the same time, the code is modularized enough
to make it easy to extract the code, in order to make a separate plugin. The
motivation for having a separate plugin to rank clusters in Cytoscape gets
bigger if ranking clusters provides useful information, in regards of
discovering cancer.

Adding new ranking algorithms should be easy both to implement and unit test.
Where the algorithms should be placed and how to connect it to the rest of the
GUI in order to choose it, should be a no-brainer. Unit testing of the
algorithms should be possible without using the GUI. So all of the logic in the
algorithms should be excluded from the GUI. If it is not excluded from the GUI,
testing the algorithms would require menu interaction and automatization of
testing goes out the window. Every test should be able to just run in the
terminal without launching Cytoscape.

The "Factory" design pattern % reference
is used in a original way in ClusterMaker2, and for the ranking cluster
algorithms it is done a little bit different.  The GUI will not be responsible
for knowing every available algorithm, it will be the algorithm factory's. The
GUI's way of knowing which algorithms the user should be able to choose from,
will be to ask the factory for a list of all of the available algorithms. This
is an example that shows by separating the amount of components that have
knowledge about a specific piece of information, it becomes easier adding new
features. If the GUI also would have to construct a list by itself about the
available algorithms, in addition to the factory, we would end up making changes
in two places instead of just one. Twice the work for just one change - adding a
new algorithm.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% IMPLEMENTATION START %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}

\section{Intro}
The \textit{clusterMaker2} documentation for implementing new parts that is not
directly connected with clustering algorithms is non-existing (cite
documentation!). So I will make a "walk through" of how to do it and how I did it.

\section{Preparations}
The POM-file has to be updated because libraries connected to the pdf exporting
functionality is outdated. Updating the libraries, imports and the usage of
these libraries in the source code is enough to make the whole project compile
at the mentioned date.

\section{Registering a service}
In order to make it easy to implement new cluster ranking algorithms, a new task
factory for the ranking of clusters is required. It has to be registered as a
service to make it visible to the GUI menu, aswell as maintain the \textit{OSGi}
standard of components added to the \textit{clusterMaker2} project. Also,
creating a standalone plugin at a later stage will be easier if Ranklust is
properly compartmentalized.

Registering a new service listener is a way of keeping the Ranklust part out of
clusterMaker2. Though, it is still packaged within clusterMaker2's API, so that
it does not become a mess, if extra functionality is to be implemented while the
plugin resides within clusterMaker2.

\section{GetNetworkClusterTask}
ClusterMaker2 already has some REST (insert: reference to REST services +
explanation). It is used in Ranklust as a way of getting the clustering results
without changin the previous code. Though, there is a flaw in the REST service.
If the clustering algorithm you want the results from is not the last clustering
algorithm that was run on the network, it will not be able to get the results.
For now, this will stay as it is, but it should be brought up for discussion to
rather look up the table of the nodes instead of the table of the network, in
order to get the clustering results. This is because the table of the network
can only hold a single value for clustering algorithms, which will either be
nothing, or the last algorithm run on the network. The drawbacks of looking up
the table of nodes instead is the time it consumes. But the time consumed to get
all of the nodes with a specific clustering result attribute will take a shorter
time than to rerun the algorithm you want to have the results from. A third
solution can be to just ignore the algorithm used to cluster the network, as it
should not have anything to say for the ranking of the clusters. This may end up
being the final solution, as it easily can be viewed as a more "sane" (formulate
this in a different way). This option requires a new REST function to be added
to clusterMaker2. As a whole, it is highly possible that this new REST
functionality should replace the existing one. The argument to replace the
already existing algorithm is that REST functionality should hide state and
implementation from the services using the REST service to get data. The way it
is now, this is not true and it should be changed anyway.

\section{Tables vs pure OO}
One thing in particular that deserves to be mentioned is the way networks are
handled. The \textit{CyNode} objects themselves does not contain much. This is
because all of the information is saved in the form of plain cells in a
spreadsheet. This may at first seem like a way to make it easy to show
information to the user, but it is also a way of working more efficient with
network data (insert: reference to working with tables on networks is
efficient). Creating objects with attributes for each node in a huge network
will increase the amount of overhead by a pretty noticeable amount. Working with
all of the information in the way of a spreadsheet with rows and columns
includes a decrease in overhead. A new node is a new row, so in relation to
build the network structure, it is not a difference to speak of.  The difference
comes in when the nodes have several attributes. 

In a table or spreadsheet, attributes can be represented as a single column and
be created once for the whole network, instead of once for each node object
created. This assumes that getting the objects out of the table is possible by
either indexing on a number for arrays, or a unique string for map structures.
The result is both a lookup, insertion and deletion time of O(1) (insert:
reference to Big-O notation).  These times is as law as the Big-O notation goes
in terms of speed related to the size of a collection inside a data structure.
So both the creation of objects goes down, and the retrieval of attribute
information is as low as it is possible to get, when we choose to represent the
time by Big-O notation. The only drawback with this implementation is that there
is no current type of wrapper around the row and column system. So the retrieval
of information is not done the most intuitive way. But this is the way Cytoscape
works as a whole, so changing the way this works is either done through changing
the Cytoscape source code, or implementing a wrapper as a standalone function
inside clusterMaker2 or as a standalone plugin.

\section{Single value ranklust}
A simple, but effective way of ranking clusters, is just to add together the
biomarkers values and sum them up in each respective cluster. This will tell us
which cluster will have the most cancerous genes and proteins. It is not very
advanced, but an analysis show how effective it is. An alternative is also to
add scaling to the values. Should clusters with a large amount of biomarkers
receive a bonus because of the sheer amount? Should values alone be scaled
exponential in order to magnify the differences between more and lesser
cancerous biomarkers? This will be tested in the final stages of single value
ranking in Ranklust. But as a beginning, the results will come from a pure
additive algorithm.  The more advanced ones will be implemented only if the
additive algorithm show promising results.

\section{Multivalue Ranklust}
Multivalue ranking of clusters creates a larger context. More data can help
making more fine tuned results and get the validation of ranking clusters to
find biomakers, hit the significance ceiling of 95\% certainity. 
% Fix this sentence!
The question here is how should several values be combined in order to create a
single value score to rank the clusters by? The best way should be to list every
attribute to the user, and present them with options as to how the values should
be scaled. An extra option could be how to scale the values in relation each
other. The first way is the simplest way to implement so it will be tested
first. And as with the single value ranking, if the first scaling of each
individual value shows promising results for multivalue ranking, the values in
relation to each other will be considered as a way of producing more accurate
results.

\section{How to get the clusters}
As of now, the SimpleRanking algorithm for ranking the clusters has to have
access to the cluster results inside the clusterMaker2 source code. The
alternative is to work directly on the Cytoscape tables containing the same
information. The drawback working on the Cytoscape tables is the need for going
through every single node in the table in order to add it to a cluster, which is
something the source code in clusterMaker2 can serve with a single
\textit{getter} method. The drawback using the clusterMaker2 code and not the
Cytoscape tables is that the getter method to clusterMaker2 demands knowledge in
the SimpleRanking algorithm of the cluster algorithm that was used. Coupling
these two object classes together is not necessary, because of the two mentioned
ways of completing this, and the getter method used is actually implemented with
the intention of creating a REST API \cite{rest-api} for applications outside
Cytoscape. A third way could be to implement a way for all of the clustering
algorithms to save their results as a \textit{List<NodeCluster>} list. Once
again this just moves the problem a bit around and we will end up with a good
amount of duplication code to the REST API method of getting the clusters. Then
again, having the REST API getter rely on the \textit{List<NodeCluster>} getter
could make for a cleaner solution. This is definetively more work and requires
every new clustering algorithm to implement a way of creating these node
clusters.

Creating the list of node clusters every time a ranking algorithm should run is
maybe not such a bad idea. Atleast when we consider that having every clustering
algorithm saving its results could result in massive memory constraints. Every
node in the node cluster list should only be a java object reference to a node
in the Cytoscape table. A Java object reference consists of 8 bytes
\cite{java-reference-size}. So we will end up having 8 bytes for every node in
the list to a single cluster. Also, to organize it properly, a list of the
clusters also has to wrap round all of the clusters, adding another 8 bytes per
cluster entry. One simplification can be made, which is using the indexes in the
list as a cluster score attribute from the cluster algorithms. That could
exclude clustering algorithms that produce more than a single score as a result
of the clustering. A sample clustering with the affinity propagation algorithm
produces 839 clusters. That is 6,7 megabytes for only the cluster entries in the
outer list. From the same results, the biggest cluster consists of over 700
nodes. That is 5,6 megabytes of memory on a single cluster. Total amount of
nodes in the network is ends up using extra memory of 89,7 megabytes. And that
is just per clustering algorithm.

\section{Edge attribute information}
In order to work with attributes in the edges, you would think that an
additional datastructure like a simple java class like \textbf{Map} or a class
which inherits attributes from the Java \textbf{Set}-class\cite{java-set} would
be preferrable. However, this is not necessary, as Cytoscape provides both the
source and target node in an edge, together with methods to get the primary key
from both of them. This allows us to index the node table and get the cluster
information in O(1) time.

Recipe for working the nodes and edges. Only the edges require step one, nodes
can start at step 2.

\begin{enumerate}
    \item Find common or best ranked cluster between two nodes (one edge).
    \item Add score to the cluster
    \item Repeat step 1-2 for every edge
    \item Sort clusters based on rank and create a column to represent the score
\end{enumerate}

Step 1 is the thing that will take extra time for the ranking algorithms
including the edges.

There is also a question on how we should add the edge scores to the cluster.
Should we add the score of the edge when we visit both the source and the target
of the edge? Only from when we visit the source, or only the target? Should the
user be prompted about this? Should the algorithm take into account if the edge
are directional. Or maybe the user should always provide edges in a specified
form. A form that says always specify the source node first, then the target
node. Maybe it should be specific to the attribute we are working with. The ways
to go here are so many. So many that I will just specify one way, and stick to
it. 

\subsection{Edge handling}
When iterating over the list of edges in the network, check first the source
node for a match, then, if it does not have a match in the node table, look
after the target node. Then add the score to the cluster. I assume that the
direction, if any, is from the source node to the target node. That way, the
score only gets added once to the cluster per edge and it does not have anything
to say if it is the source or target node. The user should have responsibility
for having the edges directed as from the source node, to the target node, if
a direction exists at all.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% IMPLEMENTATION END %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

